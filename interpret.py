#!/usr/bin/env python3

import sys
import argparse
from argparse import RawDescriptionHelpFormatter, _HelpAction
import xml.etree.ElementTree as ET
from interpret_src.Instruction import Instruction
from interpret_src.Argument import Argument
import re
import interpret_src.errorTypes as errorTypes
import copy

class Nil:	
	"""This class just simulate Nil type"""

	def __init__(self):
		pass
	def __str__(self):
		return "nil"
	def __repr__(self):
		return "nil"

NIL = Nil()


def parseArguments():
	"""Parse arguments with slightly modifed argparse"""

	class ModifiedArgumentParser(argparse.ArgumentParser):
		"""Just override error exit status code in argparse to be correct"""
		def error(self, message):
			exitWithError(errorTypes.wrongParameters, message)

	class Modified_HelpAction(_HelpAction):
		"""
		Just override __call__ so if --help argument is combined with others 
		it exits with propper error
		"""

		def __init__(self,
				option_strings,
				dest='==SUPPRESS==',
				default='==SUPPRESS==',
				help=None):
		    super(_HelpAction, self).__init__(
				option_strings=option_strings,
				dest=dest,
				default=default,
				nargs=0,
				help=help)

		def __call__(self, parser, namespace, values, option_string=None):
			try:
				sourceArg = namespace._get_kwargs()[1][1]
				inputArg = namespace._get_kwargs()[2][1]
			except:
				parser.exit(99, '%s: error: %s\n' % (parser.prog,"Internal error"))

			if sourceArg or inputArg:
				parser.error("--help argumnet cannot be combined with others")		
			else:
				parser.print_help()
				parser.exit()
	        
	argparse._HelpAction = Modified_HelpAction

	p = ModifiedArgumentParser(formatter_class=RawDescriptionHelpFormatter, description="Interpret for IPPcode19. Source code must be in XML representation, for example generated by parse.php. If one of the arguments --input and --source is missing interpret loads particular data from stdin.", epilog="""	""", add_help=False)
	p.add_argument('--help', action='help', help='show this help message and exit')
	p.add_argument("--source", help = "file with XML representation of source code. If not given, --input is required.", metavar=('FILE'))
	p.add_argument("--input", help = "input file which will be used at interpretation. If not given, --source is required.", metavar=('FILE'))

	args = p.parse_args()

	if not (args.source or args.input):
	    p.error('Give me at least one of the arguments --input and --source')

	return args.source, args.input

def getLinesFromFile(file):
	""" 
	Get list of lines from file without line endings 
	
	Parameters: 
	file (str): file you want lines from
	
	Returns: 
	list of str: lines from file without line endings  
	"""

	if file:		
		try:
			with open(file, "r") as f:
				data = f.readlines()
		except:
			exitWithError(errorTypes.cannotOpenSourceFiles, f"File: {file}")
	else:
		return None
	
	return [line.strip() for line in data]


def exitWithError(errorType, additionalMessage = None):
	""" 
	Exit with specific error type, propper exit code and friendly text
	
	Parameters: 
	errorType (Error): Custom error object
	additionalMessage (str): Text that will be printed to stderr
	"""	

	print(errorType, file=sys.stderr)
	
	if additionalMessage:
		print(additionalMessage, file=sys.stderr)

	sys.exit(errorType.code)

def customAssert(result, errorType):
	""" 
	Custom assert that can exit with specified error type
	
	Parameters: 
	result (Bool): Result from condition that needs to be true
	"""	

	if not result:
		exitWithError(errorType)


def checkXmlHeader(sourceLines):
	""" 
	Check if xml header in source lines is correct
	
	Parameters: 
	sourceLines (list of str): source code that contains xml hedaer at the beggining
	"""	

	for line in sourceLines:
		if line.strip() != "":
			firstLineOfXml = line
			customAssert(firstLineOfXml == r'<?xml version="1.0" encoding="UTF-8"?>', errorTypes.xmlNotWellFormated)
			break	

def getInstructionsFromXml(root):
	""" 
	Get list of instructions from xml code
	
	Parameters: 
	root : root of xml code from ElementTree
	
	Returns: 
	instructionsList (list of Instruction): list of instructions indeed
	"""

	instructionsList = []

	for child in root:
		customAssert(child.tag == "instruction", errorTypes.xmlStructureSyntaxLex)

		for instrAttrib in child.attrib:
			customAssert(instrAttrib in ("order", "opcode"), errorTypes.xmlStructureSyntaxLex)

		arguments = []

		for arg in child:
			for atrib in arg.attrib:
				customAssert(atrib == "type", errorTypes.xmlStructureSyntaxLex)

			result = re.search("^arg([1-3])$", arg.tag)

			customAssert(result, errorTypes.xmlStructureSyntaxLex)
			
			order = result.group(1)
			argument = Argument(arg.get("type"), arg.text, order)
			arguments.append(argument)

		arguments.sort(key=lambda argument: argument.order)

		# Assert if in instruction is for example just arg2, but arg1 is missing, also duplicates
		for index, argument in enumerate(arguments,  start=1):
			customAssert(argument.order == index, errorTypes.xmlStructureSyntaxLex)

		instruction = Instruction(child.get("opcode"), arguments, child.get("order"))
		instructionsList.append(instruction)
  
	instructionsList.sort(key=lambda instruction: instruction.order)

	# Assert if for example there is instruction with order 2 but instruction with order 1 is missing, 
	# also when there are order duplicates
	for index, instruction in enumerate(instructionsList,  start=1):
		customAssert(instruction.order == index, errorTypes.xmlStructureSyntaxLex)	

	return instructionsList


def makeInstructionRule(name, arg_1=None, arg_2=None, arg_3=None):
	""" 
	Make one Instruction from instruction and arguments names. E.g. <MOVE> <var> <symb>
	
	Parameters: 
	name (str) : Name of instruction
	arg_1 (str) : Name of 1. argument
	arg_2 (str) : Name of 2. argument
	arg_3 (str) : Name of 3. argument
	
	Returns: 
	Instruction : new instruction according to parameters
	"""

	arguments = []

	if arg_1:
		arguments.append(Argument(arg_1))
	if arg_2:
		arguments.append(Argument(arg_2))
	if arg_3:
		arguments.append(Argument(arg_3))

	return Instruction(name, arguments)

def getInstrutionsRules():
	""" 
	Get instruction rules, this defines IPPcode19 syntax
	
	Returns: 
	instructionRules (list of Instruction) : filled instruction rules
	"""	

	instructionRules = []

	instructionRules.append(makeInstructionRule("MOVE", "var", "symb"))
	instructionRules.append(makeInstructionRule("CREATEFRAME"))
	instructionRules.append(makeInstructionRule("PUSHFRAME"))
	instructionRules.append(makeInstructionRule("POPFRAME"))
	instructionRules.append(makeInstructionRule("DEFVAR", "var"))
	instructionRules.append(makeInstructionRule("CALL", "label"))
	instructionRules.append(makeInstructionRule("RETURN"))
	instructionRules.append(makeInstructionRule("PUSHS", "symb"))
	instructionRules.append(makeInstructionRule("POPS", "var"))	
	instructionRules.append(makeInstructionRule("ADD", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("SUB", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("MUL", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("IDIV", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("LT", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("GT", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("EQ", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("AND", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("OR", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("NOT", "var", "symb"))
	instructionRules.append(makeInstructionRule("INT2CHAR", "var", "symb"))
	instructionRules.append(makeInstructionRule("STRI2INT", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("READ", "var", "type"))
	instructionRules.append(makeInstructionRule("WRITE", "symb"))
	instructionRules.append(makeInstructionRule("CONCAT", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("STRLEN", "var", "symb"))
	instructionRules.append(makeInstructionRule("GETCHAR", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("SETCHAR", "var", "symb", "symb"))
	instructionRules.append(makeInstructionRule("TYPE", "var", "symb"))
	instructionRules.append(makeInstructionRule("LABEL", "label"))
	instructionRules.append(makeInstructionRule("JUMP", "label"))
	instructionRules.append(makeInstructionRule("JUMPIFEQ", "label", "symb", "symb"))
	instructionRules.append(makeInstructionRule("JUMPIFNEQ", "label", "symb", "symb"))
	instructionRules.append(makeInstructionRule("EXIT", "symb"))
	instructionRules.append(makeInstructionRule("DPRINT", "symb"))
	instructionRules.append(makeInstructionRule("BREAK"))

	return instructionRules


def checkOperandLexems(instructionsList):
	""" 
	Chceck if lexems in operands are correct
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	"""

	for instruction in instructionsList:
		for argument in instruction.arguments:
			if argument.type == "var":
				result = re.search(r'^(GF|LF|TF)@([a-z]|[A-Z]|[\_\-\$\&\%\*\?\!])(\w|[\_\-\$\&\%\*\?\!])*$', argument.name)
			elif argument.type == "string":
				result = re.search(r'^([^\s\#\\]|\\[0-9]{3})*$', argument.name)	
			elif argument.type == "int":
				result = re.search(r'^[-\+]?[0-9]+$', argument.name)	
			elif argument.type == "bool":
				result = re.search(r'^(false|true)$', argument.name)	
			elif argument.type == "nil":
				result = re.search(r'^nil$', argument.name)				
			elif argument.type == "label":
				result = re.search(r'^([a-z]|[A-Z]|[\_\-\$\&\%\*\?\!])(\w|[\_\-\$\&\%\*\?\!])*$', argument.name)
			elif argument.type == "type":
				result = re.search(r'^(string|int|bool)$', argument.name)				
			else:
				result = False

			customAssert(result, errorTypes.xmlStructureSyntaxLex)

def checkSyntax(instructionsList):
	""" 
	Check syntax in source coce
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	"""	

	instructionRules = getInstrutionsRules();

	for instruction in instructionsList:
		customAssert(instruction in instructionRules, errorTypes.xmlStructureSyntaxLex)

def checkLabelsSematics(instructionsList):
	""" 
	Check labels semantics, i.e. if there is redefinition or using not defined label
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	"""

	definedLabels = []

	# Find labels, check if there is no attempt of redefinition
	for instruction in instructionsList:
		if instruction.name == "LABEL":
			labelName = instruction.arguments[0].name
			customAssert(labelName not in definedLabels, errorTypes.semantics)

			definedLabels.append(labelName)

	# Check if label not defined
	for instruction in instructionsList:
		if instruction.name != "LABEL":
			for argument in instruction.arguments:
				if argument.type == "label":
					customAssert(argument.name in definedLabels, errorTypes.semantics)

def replaceEscapeSequences(instructionsList):
	""" 
	Replace escape sequences in string types in source code. E.g. a\032a => a a
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	
	Returns: 
	instructionsList (list of Instruction) : list of instructions with replaced escape sequences
	"""

	for instruction in instructionsList:
		for argument in instruction.arguments:
			if argument.type == "string":
				escapedUnicodesList = re.findall(r'(\\[0-9]{3})+', argument.name)

				for escapedUnicode in escapedUnicodesList:
					unicodeAsChar = chr(int(escapedUnicode[1:]))
					argument.name = argument.name.replace(escapedUnicode, unicodeAsChar)

	return instructionsList

def readInput(inputLines):
	""" 
	Generalizes reading from input. 
	If there is file with input text take data from there, otherwise read from stdin
	
	Parameters: 
	inputLines (list of str) : from file that user added as cli argument
	
	Returns: 
	String : text from input
	"""	

	if inputLines != None:
		return inputLines.pop(0)
	else:
		return input()


def	getLablesIndexes(instructionsList):
	""" 
	Get labels name from source code with indexes, so it will be easier to do jumps to labels
	E.g.:  {"foo" : 5, "boo" : 9}
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	
	Returns: 
	labelsIndexDict (Dictionary) : labels name from source code with indexes 
	"""	

	labelsIndexDict = {}

	for i, instruction in enumerate(instructionsList):
	 	if instruction.name == "LABEL":
	 		labelName = instruction.arguments[0].name
	 		labelsIndexDict[labelName] = i

	return labelsIndexDict


def interpretCode(instructionsList, inputLines):
	""" 
	Interpert code
	
	Parameters: 
	instructionsList (list of Instruction) : list of instructions from source code
	inputLines (list of str) : from file that user added as cli argument 
	"""	

	# Position of labels in instructionsList  E.g.:  {"foo" : 5, "boo" : 9}
	# So it will be easier to jumping to these labes
	labelsIndexDict = getLablesIndexes(instructionsList)

	GF = {}
	LF = []
	TF = None

	stackPushsPops = []
	stackReturnToCaller = []

	dataToDestination = None
	destinationData = None
	sourceDataFirst = None
	sourceDataSecond = None
	labelToJump = None

	currentInstructionIndex = 0
	processedInstructionsCount = 0

	while currentInstructionIndex < len(instructionsList):

		instruction = instructionsList[currentInstructionIndex]
		currentInstructionIndex += 1
		processedInstructionsCount += 1

		# Semantics assert and get data from instruction source and destination argmuents
		for argument in instruction.arguments:

				# For classic: INSTRUCTION dest [source] [source]
				if argument.type == "var" and argument.order == 1 and instruction.name not in ("PUSHS", "WRITE", "EXIT", "DPRINT"):
					frame = argument.name.split("@", 1)[0]
					varName = argument.name.split("@", 1)[1]

					if frame == "GF":			
						if instruction.name != "DEFVAR":
							customAssert(varName in GF, errorTypes.variableNotDefined)
							destinationData = GF[varName]				
					elif frame == "LF":
						customAssert(len(LF) != 0, errorTypes.frameNotExists)
						if instruction.name != "DEFVAR":
							customAssert(varName in LF[-1], errorTypes.variableNotDefined)					
							destinationData = LF[-1][varName]				
					elif frame == "TF":
						customAssert(TF != None, errorTypes.frameNotExists)
						if instruction.name != "DEFVAR":
							customAssert(varName in TF, errorTypes.variableNotDefined)					
							destinationData = TF[varName]				

				# For classic: INSTRUCTION dest source [source]   E.g.: ADD var symb symb
				#          Or: INSTRUCTION source                 E.g.: WRITE symb
				if argument.order in (2, 3) or instruction.name in ("PUSHS", "WRITE", "EXIT", "DPRINT"):
					if argument.type == "var":
						frame = argument.name.split("@", 1)[0]
						varName = argument.name.split("@", 1)[1]

						if frame == "GF":
							customAssert(varName in GF, errorTypes.variableNotDefined)
							sourceData = GF[varName]
						elif frame == "LF":
							customAssert(len(LF) != 0, errorTypes.frameNotExists)
							customAssert(varName in LF[-1], errorTypes.variableNotDefined)
							sourceData = LF[-1][varName]
						elif frame == "TF":
							customAssert(TF != None, errorTypes.frameNotExists)
							customAssert(varName in TF, errorTypes.variableNotDefined)
							sourceData = TF[varName]

						# Because second argument in TYPE dont have to be initialized
						customAssert(sourceData != None or instruction.name == "TYPE", errorTypes.missingValue)

					elif argument.type in ("string", "type"):
						sourceData = argument.name
					elif argument.type == "int":
						sourceData = int(argument.name)
					elif argument.type == "bool":
						sourceData = argument.name == "true"
					elif argument.type == "nil":
						sourceData = NIL			

					if argument.order in (1, 2):
						sourceDataFirst = sourceData
					elif argument.order == 3:
						sourceDataSecond = sourceData				

				elif argument.type == "label":
					labelToJump = argument.name


		if instruction.name == "DEFVAR":

			dataToDestination = None

		elif instruction.name == "MOVE":

			dataToDestination = sourceDataFirst

		elif instruction.name == "CREATEFRAME":

			TF = {}

		elif instruction.name == "PUSHFRAME":
			customAssert(TF != None, errorTypes.frameNotExists)
			LF.append(TF)	
			TF = None

		elif instruction.name == "POPFRAME":
			customAssert(len(LF) != 0, errorTypes.frameNotExists)
			TF = LF.pop()

		elif instruction.name == "WRITE":
			if type(sourceDataFirst) != Nil:
				if type(sourceDataFirst) == bool:
					print(str(sourceDataFirst).lower(), end="")
				else:
					print(sourceDataFirst, end="")

		elif instruction.name == "READ":
			expectedType = sourceDataFirst

			try:
				readedData = readInput(inputLines)
			except:
				readedData = 0
				if expectedType == "string":
					readedData = ""

			if expectedType == "string":
				readedData = str(readedData)
			elif expectedType == "int":
				try:
					readedData = int(readedData)
				except:
					readedData = 0
			elif expectedType == "bool":				
				readedData = str(readedData).lower() == "true"

			dataToDestination = readedData

		elif instruction.name == "ADD":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst + sourceDataSecond

		elif instruction.name == "SUB":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst - sourceDataSecond

		elif instruction.name == "MUL":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst * sourceDataSecond

		elif instruction.name == "IDIV":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			customAssert(sourceDataSecond != 0, errorTypes.wrongOperandValue)
			dataToDestination = sourceDataFirst // sourceDataSecond									

		elif instruction.name == "LT":
			customAssert(type(sourceDataFirst) == type(sourceDataSecond), errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst < sourceDataSecond
		
		elif instruction.name == "GT":
			customAssert(type(sourceDataFirst) == type(sourceDataSecond), errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst > sourceDataSecond

		elif instruction.name == "EQ":
			customAssert(type(sourceDataFirst) == type(sourceDataSecond) 
							or type(sourceDataFirst) == Nil 
							or type(sourceDataSecond) == Nil, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst == sourceDataSecond

		elif instruction.name == "AND":
			customAssert(type(sourceDataFirst) == bool, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == bool, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst and sourceDataSecond

		elif instruction.name == "OR":
			customAssert(type(sourceDataFirst) == bool, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == bool, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst or sourceDataSecond

		elif instruction.name == "NOT":
			customAssert(type(sourceDataFirst) == bool, errorTypes.wrongOperandType)
			dataToDestination = not sourceDataFirst

		elif instruction.name == "PUSHS":

			stackPushsPops.append(sourceDataFirst)

		elif instruction.name == "POPS":
			customAssert(len(stackPushsPops) != 0, errorTypes.missingValue)	
			dataToDestination = stackPushsPops.pop()

		elif instruction.name == "JUMP":

			currentInstructionIndex = labelsIndexDict[labelToJump]

		elif instruction.name == "JUMPIFEQ":
			customAssert(type(sourceDataFirst) == type(sourceDataSecond), errorTypes.wrongOperandType)
			if sourceDataFirst == sourceDataSecond:
				currentInstructionIndex = labelsIndexDict[labelToJump]

		elif instruction.name == "JUMPIFNEQ":
			customAssert(type(sourceDataFirst) == type(sourceDataSecond), errorTypes.wrongOperandType)
			if sourceDataFirst != sourceDataSecond:
				currentInstructionIndex = labelsIndexDict[labelToJump]

		elif instruction.name == "CALL":
			stackReturnToCaller.append(currentInstructionIndex)
			currentInstructionIndex = labelsIndexDict[labelToJump]		

		elif instruction.name == "RETURN":
			customAssert(len(stackReturnToCaller) != 0, errorTypes.missingValue)
			currentInstructionIndex = stackReturnToCaller.pop()					

		elif instruction.name == "INT2CHAR":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			try:
				dataToDestination = chr(sourceDataFirst)
			except:
				exitWithError(errorTypes.wrongStringManipulation)

		elif instruction.name == "STRI2INT":
			customAssert(type(sourceDataFirst) == str, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			try:
				dataToDestination = ord(sourceDataFirst[sourceDataSecond])
			except:
				exitWithError(errorTypes.wrongStringManipulation)

		elif instruction.name == "CONCAT":
			customAssert(type(sourceDataFirst) == str, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == str, errorTypes.wrongOperandType)
			dataToDestination = sourceDataFirst + sourceDataSecond

		elif instruction.name == "STRLEN":
			customAssert(type(sourceDataFirst) == str, errorTypes.wrongOperandType)
			dataToDestination = len(sourceDataFirst)

		elif instruction.name == "GETCHAR":
			customAssert(type(sourceDataFirst) == str, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == int, errorTypes.wrongOperandType)
			try:
				dataToDestination = sourceDataFirst[sourceDataSecond]
			except:
				exitWithError(errorTypes.wrongStringManipulation)

		elif instruction.name == "SETCHAR":
			customAssert(type(destinationData) == str, errorTypes.wrongOperandType)
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(type(sourceDataSecond) == str, errorTypes.wrongOperandType)

			destinationData = list(destinationData)

			try:
				destinationData[sourceDataFirst] = sourceDataSecond[0]
				dataToDestination = "".join(destinationData)
			except:
				exitWithError(errorTypes.wrongStringManipulation)				

		elif instruction.name == "TYPE":
			# Non initialized variable
			if sourceDataFirst == None:
				dataToDestination = ""
			elif type(sourceDataFirst) == Nil:
				dataToDestination = "nil"
			elif type(sourceDataFirst) == int:
				dataToDestination = "int"
			elif type(sourceDataFirst) == str:
				dataToDestination = "string"
			elif type(sourceDataFirst) == bool:
				dataToDestination = "bool"

		elif instruction.name == "EXIT":
			customAssert(type(sourceDataFirst) == int, errorTypes.wrongOperandType)
			customAssert(0 <= sourceDataFirst <= 49, errorTypes.wrongOperandValue)
			sys.exit(sourceDataFirst)

		elif instruction.name == "DPRINT":
			if type(sourceDataFirst) != Nil:
				if type(sourceDataFirst) == bool:
					print(str(sourceDataFirst).lower(), file=sys.stderr, end="")
				else:	
 					print(sourceDataFirst, file=sys.stderr, end="")

		elif instruction.name == "BREAK":
			print("Current instruction index:", currentInstructionIndex - 1, file=sys.stderr)
			print("Number of procesed instructions:", processedInstructionsCount, "(including this BREAK)", file=sys.stderr)
			print("GF:", GF, file=sys.stderr)
			print("TF:", TF, file=sys.stderr)
			print("LF:", LF, file=sys.stderr)


		# Write dataToDestination to destination variable in frame
		if len(instruction.arguments) != 0:
			if instruction.arguments[0].type == "var" and instruction.name not in ("PUSHS", "WRITE", "EXIT", "DPRINT"):
				frame = instruction.arguments[0].name.split("@", 1)[0]
				varName = instruction.arguments[0].name.split("@", 1)[1]

				if frame == "GF":					
					GF[varName] = dataToDestination
				elif frame == "LF":
					LF[-1][varName] = dataToDestination
				elif frame == "TF":
					TF[varName] = dataToDestination

		
def main():
	sourceFile, inputFile = parseArguments()

	if sourceFile:
		sourceLines = getLinesFromFile(sourceFile)
	else:
		sourceLines = [line.strip() for line in sys.stdin]	 
	
	inputLines = getLinesFromFile(inputFile)

	try:
		root = ET.fromstringlist(sourceLines)
	except:
		exitWithError(errorTypes.xmlNotWellFormated)

	customAssert(root.tag == "program", errorTypes.xmlStructureSyntaxLex)
	customAssert(root.get("language") == "IPPcode19", errorTypes.xmlStructureSyntaxLex)
	for atrib in root.attrib:
		customAssert(atrib in ("language", "name" , "description"), errorTypes.xmlStructureSyntaxLex)
	checkXmlHeader(sourceLines)

	instructionsList = getInstructionsFromXml(root)

	checkOperandLexems(instructionsList)
	checkSyntax(instructionsList)

	checkLabelsSematics(instructionsList)

	instructionsList = replaceEscapeSequences(instructionsList)

	interpretCode(instructionsList, inputLines)


if __name__== "__main__":
	main()
